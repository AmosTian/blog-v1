---
sort: 1
---

# 0-编程能力

## 0.1 基本数据类型

### 1523.在区间范围内统计奇数数目

奇数，第一反应是 `n%2==1` ,所以直接写成下面代码，结果超时。计算除法的代价显然比加减法大得多

```c++
class Solution {
public:
    int countOdds(int low, int high) {
        int cnt=0;
        for(int i=low;i <= high;++i)
            if(i % 2==1)
                cnt++;

    return cnt;
    }
};
```

又想整数，一定是 **奇、偶、...** 或 **偶、奇...**

所以已经给定区间范围，[左,右]，右-左= (左,右] 或 [左,右) 包含的整数个数，折半则为奇数个数

且分为以下情况

1.  [奇,奇]
2.  [奇,偶]
3.  [偶,奇]
4.  [偶,偶]

故需判断一侧边界是否为奇数，若其为奇数，则个数加1。由于闭区间的对称性，两侧都要判断，且左右判别式间关系为或。

```c++
class Solution {
public:
    int countOdds(int low, int high) {
        int cnt=0;
        if(low % 2==1  || high%2==1)
            cnt=1;
        cnt += (high-low)/2;

        return cnt;
    }
};
```

#### 前缀和思想

pre(x)为区间 $$[0,x]$$ 内奇数个数，显然 $$pre(x)=\lfloor \frac{x+1}{2} \rfloor$$ ,故区间[low,high]内奇数个数为 pre(high)-pre(low-1)

**计算机中乘除法运算没有移位运算快**

```c++
class Solution {
public:
    int pre(int x) {
        return (x + 1) >> 1;
    }
    
    int countOdds(int low, int high) {
        return pre(high) - pre(low - 1);
    }
};
```

**判断奇偶的方法**：`x&1` 

### 1491. 去掉最低工资和最高工资后的工资平均值

第一想法，简单选择，一轮遍历，以为会超时竟然过了。

```c++
class Solution {
public:
    double average(vector<int>& salary) {
        double min = salary[0];
        double max = salary[0];
        double sum = 0;
        for(int i = 0;i < salary.size();++i){
            if(min > salary[i])
                min = salary[i];
            if(max < salary[i])
                max = salary[i];
            sum += salary[i];
        }
        return (sum-min-max)/(salary.size()-2);
    }
};
```

-   因为是新手村的入门题，甚至连数据都是唯一的，非常友好了。

答案想法类似，只是用了 **容器** 的内置方法寻找最值

-   `algorithm` 库的 `max_element()、min_element()` 返回容器中最小值和最大值的 **指针**
-   `numeric` 库的 `accumulate(起点,终点,权值)` ：直接计算数组或者容器中C++内置数据类型

```c++
#include<algorithm>//max_element()、min_element()
# include<numeric>

class Solution {
public:
    double average(vector<int>& salary) {
        double maxValue = *max_element(salary.begin(), salary.end());
        double minValue = *min_element(salary.begin(), salary.end());
        double sum = accumulate(salary.begin(), salary.end(), - maxValue - minValue);
        return sum / int(salary.size() - 2);
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution/qu-diao-zui-di-gong-zi-he-zui-gao-gong-zi-hou-de-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
