---
sort: 1
---

# 0. 编程能力

## 0.1 基本数据类型

### 1523.在区间范围内统计奇数数目

奇数，第一反应是 `n%2==1` ,所以直接写成下面代码，结果超时。计算除法的代价显然比加减法大得多

```c++
class Solution {
public:
    int countOdds(int low, int high) {
        int cnt=0;
        for(int i=low;i <= high;++i)
            if(i % 2==1)
                cnt++;

    return cnt;
    }
};
```

又想整数，一定是 **奇、偶、...** 或 **偶、奇...**

所以已经给定区间范围，[左,右]，右-左= (左,右] 或 [左,右) 包含的整数个数，折半则为奇数个数

且分为以下情况

1.  [奇,奇]
2.  [奇,偶]
3.  [偶,奇]
4.  [偶,偶]

故需判断一侧边界是否为奇数，若其为奇数，则个数加1。由于闭区间的对称性，两侧都要判断，且左右判别式间关系为或。

```c++
class Solution {
public:
    int countOdds(int low, int high) {
        int cnt=0;
        if(low % 2==1  || high%2==1)
            cnt=1;
        cnt += (high-low)/2;

        return cnt;
    }
};
```

#### 前缀和思想

pre(x)为区间 $$[0,x]$$ 内奇数个数，显然 $$pre(x)=\lfloor \frac{x+1}{2} \rfloor$$ ,故区间[low,high]内奇数个数为 pre(high)-pre(low-1)

**计算机中乘除法运算没有移位运算快**

```c++
class Solution {
public:
    int pre(int x) {
        return (x + 1) >> 1;
    }
    
    int countOdds(int low, int high) {
        return pre(high) - pre(low - 1);
    }
};
```

**判断奇偶的方法**：`x&1` 

### 1491. 去掉最低工资和最高工资后的工资平均值

第一想法，简单选择，一轮遍历，以为会超时竟然过了。

```c++
class Solution {
public:
    double average(vector<int>& salary) {
        double min = salary[0];
        double max = salary[0];
        double sum = 0;
        for(int i = 0;i < salary.size();++i){
            if(min > salary[i])
                min = salary[i];
            if(max < salary[i])
                max = salary[i];
            sum += salary[i];
        }
        return (sum-min-max)/(salary.size()-2);
    }
};
```

-   因为是新手村的入门题，甚至连数据都是唯一的，非常友好了。

答案想法类似，只是用了 **容器** 的内置方法寻找最值

-   `algorithm` 库的 `max_element()、min_element()` 返回容器中最小值和最大值的 **指针**
-   `numeric` 库的 `accumulate(起点,终点,权值)` ：直接计算数组或者容器中C++内置数据类型

```c++
#include<algorithm>//max_element()、min_element()
# include<numeric>

class Solution {
public:
    double average(vector<int>& salary) {
        double maxValue = *max_element(salary.begin(), salary.end());
        double minValue = *min_element(salary.begin(), salary.end());
        double sum = accumulate(salary.begin(), salary.end(), - maxValue - minValue);
        return sum / int(salary.size() - 2);
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution/qu-diao-zui-di-gong-zi-he-zui-gao-gong-zi-hou-de-4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 0.2 运算符

### 191. 位1的个数

第一想法是位运算，结合上面奇数的判断方法 `n&1==1` ，则当前位为1，故1的个数加1。因为输入的二进制字符串长度不变呢，所以右移位数确定，循环判断条件也可是 `for(int i = 0;i < 32;++i)` 

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt = 0;
        while(n){
            if(n&1)
                cnt++;
            n>>=1;//右移一位
        }

        return cnt;
    }
};
```

-   本题一开始卡在右移， `n>>1` 忘写赋值符号 `n>>=1` 导致死循环，判别为超时

答案的第一种做法和上述类似，只是移位方向不同，第一想法是1不动，数字右移，答案第一种是数字不动，用1左移。

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        for (int i = 0; i < 32; i++) {
            if (n & (1 << i)) {
                ret++;
            }
        }
        return ret;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

方法二：

这个真想不出来：n&(n - 1)，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果

 就是说 

11111111111111111111111111111111 & 11111111111111111111111111111110 变为 11111111111111111111111111111110

11111111111111111111111111111110 & 11111111111111111111111111111101 变为 11111111111111111111111111111100

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

-   真值的二进制为logn,故时间复杂度为logn

### 1281. 整数的各位积和之差

求每个数位上的数字

```c++
class Solution {
public:
    int subtractProductAndSum(int n) {
        int product = 1;
        int sum = 0;
        while(n){
            int a = n%10;
            sum += a;
            product *= a;
            n/=10;
        }
        return product-sum;
    }
};
```

时间复杂度：$$O(logN)$$ 由于整数N的位数为 $$\lceil log_{10}N = \frac{log_2{N}}{log_210} \rceil$$ 即相差常数，故数量级为O(logN)

空间复杂度：O(1)

## 0.3 条件语句

### 976. 三角形的最大周长

最初考虑只有三个元素

```c++
class Solution {
public:
    int largestPerimeter(vector<int>& nums) {
        sort(nums.begin(),nums.end());//122 112
        if(nums[0]+nums[1] <= nums[2] || nums[2]-nums[0] >= nums[1])
            return 0;
        return accumulate(nums.begin(),nums.end(),0);
    }
};
```

<img src="0.编程能力.assets/image-20220213085838921.png" alt="image-20220213085838921" style="zoom: 50%;" />

显然想简单了

**排序+贪心**，从数组尾部开始逆序遍历，若找到可以构成三角形的，则直接输出其周长，若迭代器回到 `nums.begin()+1` 都不能构成三角形，则返回0

```c++
class Solution {
public:
    int largestPerimeter(vector<int>& nums) {
        sort(nums.begin(),nums.end()); 
        vector<int>::iterator it = nums.end()-1;
        
        while(it != nums.begin()+1){
            if(*it-*(it-2) < *(it-1) && *(it-2)+*(it-1) > *it)
                return accumulate(it-2,it+1,0);
            it--;
        }    
        return 0;
    }
};
```

<img src="0.编程能力.assets/image-20220213115943771.png" alt="image-20220213115943771" style="zoom:50%;" />

显然效率不够高。还是看答案

<img src="0.编程能力.assets/image-20220213120538464.png" alt="image-20220213120538464" style="zoom:80%;" />

这么一看咱思想还是跟的上的。

### 1779. 找到最近的有相同 X 或 Y 坐标的点

就一些数学库函数的运用，在设置 `min` 时，一开始用 $$10^4$$ 不对，以下示例会出错

```c++
vector<vector<int>> points = {{5,45},{60,19},{11,38},{32,22},{1,24},{26,25},{52,36},{45,54},{45,30},{45,39},{39,38},{25,38},{39,57},{47,51},{47,49},{37,21},{16,43},{53,33},{10,50},{30,29},{3,31},{45,26},{22,40},{2,31},{57,42},{25,42},{37,13},{13,54},{17,5},{50,32}};
int x = 28,y = 51;
```

运行结果是 -1，进不了内层 `if`

```c++
class Solution {
public:
    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {
        int min = INT_MAX;
        int idx=-1;
        for(int i = 0;i < points.size();++i){
            if(points[i][0]==x || points[i][1]==y){
                if(min > abs(x-points[i][0])+abs(y-points[i][1])){
                    min = abs(x-points[i][0])+abs(y-points[i][1]);
                    idx = i;
                }
            }
        }
        return idx;
    }
};
```

